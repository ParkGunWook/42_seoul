# 소개

c언어에서 프엪 함수의 다재다능함은 우리에게 프로그래밍을 위한 좋은 연습이 될 것이다. 이 프로젝트는 꽤나 어렵다. 그것은 너가 C에서 다재다능한 함수를 발견하는 것을 가능하게 해줄 것이다.
성공적인 **ft_printf**를 향한 키는 잘 구조화되어 있고 확장 가능한 좋은 코드이다.


# 공통 명세

- 너의 프로젝트는 반드시 Norm에 맞추어서 쓰여야한다. 만약 너가 보너스 파일/함수를 가지면, 그들은 놈에 체크되고 놈에 오류가 있다면 너는 0점을 받게 될 것이다.

- 너의 함수는 정의되지 않은 행동으로 인해서 비정상적으로 종료되지 않아야한다. 만약 그것이 일어나면, 너의 프로젝트는 작동하지 않는다고 고려되고 너는 평가동안에 0점을 받게 될 것이다.

- 힙메모리에 할당된 모든 공간은 필요할때 적절하게 해제되어야한다. 어떠한 릭도 허용되지 않는다.

- 만약 서브젝트가 필요로 하면, 너는 너의 소스 파일을 적절한 플래그로 컴파일해야하고 반드시 **Makefile**을 제출해야한다. 그리고 너의 메이크 파일은 반드시 리링크되지 않아야한다.

- 너의 메이크 파일은 반드시 $(NAME), all, clean, flcean, re를 가져야한다.

- 너의 프로젝트에서 보너스를 제출하면, 메이크 파일에 너는 bonus룰을 포함해야한다. 프로젝트의 메인 파트에서 허용되지 않은 모든 다양한 헤더, 라이브러리 또는 함수를 추가한다. 보너스는 반드시 다른 파일 _bonus.{c/h}안에 있어야한다. 의무와 보너스 파트 평가는 분리되서 실행된다.

- 만약 너의 프로젝트가 libft를 사용하게하면 너는 반드시 너의 소스를 복사하고 그것의 관련된 Makefile을 가져와야한다. 너의 프로젝트의 메이크 파일은 그것의 Makefile을 이용함으로서 라이브러리를 컴파일 해야하고, 프로젝트를 컴파일해야한다.

- 우리는 너가 너의 프로젝트에서 제출되지도 않고 채점되지도 않을 테스트프로그램을 생성하도록 독려한다. 그것은 너의 작업과 너의 동료의 작업을 쉽게 테스트할 기회를 줄 것이다. 너는 이런 테스트가 너의 디펜스에서 도움이 될 것이라는 것을 알 수 있다. 실제로, 디펜스하는 동안에, 너는 너의 테스트를 사용하거나 동료의 작업을 테스트할 때 도움될 것이다.

- 너의 작업물을 제공된 깃 레포에 작업해라. 오직 깃레포의 워크만이 채점된다. 만약 딥솟이 너의 작업을 채점하려고할당되면, 그것은 동료평가가 끝난 후일 것이다. 만약 에러가 너의 작업의 어떤 섹션에서 발생한다하면 평가는 멈춘다.

# 의무 파트

| | |
| - | - |
| 프로그램 명 | libftprintf.a |
| 제출 파일들 | \*.c \*/\*.c, \*/\*.h, Makefile |
| 외부 함수 | malloc, free, write, va_start, va_arg, va_copy, va_end |
| Libft 허용 | yes |
| 설명 | 실제 printf를 모방한 ft_printf를 포함한 라이브러리를 작성한다. |

- `ft_printf`의 프로토타입은 반드시 `int ft_printf(const char *, ...);`이다.

- 너는 반드시 `libc's printf` 함수를 리코딩해야한다.

- 그것은 실제 `printf`처럼 버퍼 관리를 하지 않아야한다.

- 그것은 다음과 같은 컨버전을 관리 해야한다. : cspdiuxX%(char, string, pointer)

- 그것은 다음과 같은 플래그를 처리해야한다. '-0.*', 그리고 모든 컨버전에 대해서 최소한의 필드 너비

- 그것은 실제 `printf`와 비교될 것이다.

- 너는 반드시 ar을 이용해서 너의 라이브러리를 만들어야한다.

> man 3 printf / man 3 stdarg

## 0. 프엪이란?
[출처 : 모두의 코드](https://modoocode.com/35)

일련의 데이터를 특정한 형식에 맞추어 `stdout`에 출력한다.

표준 출력(stdout)에 일련의 데이터들을 형식 문자열(format)에 지정되어 있는 형태로 출력한다.

형식 문자열 다음에는 출력할 데이터들을 나열한다. `printf` 함수는 적어도 형식 문자열 속에 지정된 데이터 이상의 인자를 받기로 기대한다.

## 1. 인자

형식 문자열(format) 형식 문자열에는 `stdout`에 출력할 문자열이 들어있다.

이 때, 형식 문자열에는 형식 태그라 불리는 것이 추가적으로 들어갈 수 있는데, 이는 이에 대응하는 인자를 형식 태그가 지정한 형태로 치환되어 출력된다. 따라서 형식 문자열 다음으로 오는 인자들의 개수는 반드시 형식 문자열 속의 태그의 개수보다 같거나 많아야 한다.

형식 태그는 아래와 같은 꼴로 생겼다.

`%[플래그][폭][.정밀도][크기]서식 문자(specifier)`

### 1. 서식문자

| 서식 문자 | 출력 형태 | 예시 |
| - | - | - |
| c | 문자 | a |
| s | 문자열 | sample |
| p | 포인터 주소 | B800:0000|
| d | 부호 있는 십진법으로 나타난 정수 | 392 |
| i | 부호 있는 십진법으로 나타난 정수 | 392 |
| u | 부호없는 십진법으로 나타낸 정수 | 7235 |
| x | 부호없는 16 진법으로 나타낸 정수(소문자 사용) | 7fa |
| X | 부호없는 16 진법으로 나타낸 정수(대문자 사용) | 7FA |
| % | `%` 다음에 %를 또 붙이면 `stdout`에 `%`를 출력한다. | % |
| 보너스 | | |
| n | 아무것도 출력하지 않는다. 그 대신, 인자로 부호 있는 int 형을 가리키는 포인터를 전달해야 되는데, 여기에 현재까지 쓰여진 문자 수가 저장된다. | |
| f | 십진법으로 나타낸 부동 소수점 수 | 392.65 |
| g | %e나 %f 보다 간략하게 출력 | 392.65 |
| e | 지수 표기법으로 출력하되, `e` 문자를 이용한다. | 3.9265e+2 |

### 2. 플래그

형식 태그에는 위 말고도 플래그, 폭, .정확도, 제한자, 부-서식문자에 관련한 정보들이 포함될 수 있다. 먼저 플래그를 살펴보면 플래그는 기본적으로 출력되는 형태에 대해 조금 더 자세하게 지정할 수 있게 해준다. 플래그는 아래와 같다.

| 플래그 | 설명 |
| - | - |
| 0 | 수들은 왼쪽으로 정렬하되 빈 칸을 삽입하는 대신에 0을 삽입한다.(폭 지정자 참조) precision 플래그가 있으면 무시된다. |
| - | 수들은 오른쪽으로 정렬된다. |
| 보너스 | |
| + | 출력 결과값이 양수인 경우라도 `+`기호를 앞에 붙여서 출력하도록 한다.(물론 음수면 자동적으로 `-`가 붙는다.) 기본적으로 지정하지 않았을 경우 음수에만 앞에 `-`가 붙는다. |
| 공백 | 앞에 부호가 붙지 않는다면 한 칸을 띄어서 출력한다. (다시말해 123은 " 123"으로 출력되고 -123은 "-123"으로 출력된다.) |
| # | `x, X` 서식 문자들과 사용되면 출력되는 값 앞에 각각 `0x, 0X`가 붙게 된다.(이 때 0은 제외한다.) `e, E, f` 서식 문자들과 사용되면 소수점 아래 수들이 없음에도 불구하고 강제적으로 소수점을 붙이도록 한다. 원래 소수점 아래 수들이 없다면 소수점을 붙이지 않는다. `g` 서식 문자들과 사용되면 `e` 일떄와 동일한 작업을 하지만 소수들의 뒷부분에 붙는 0들은 제거되지 않는다.

### 3. 폭

폭은 말그대로 출력되는 데이터의 폭을 지정해준다. 참고로 여기서의 폭(width)은 뒤에 나오는 길이(length)와는 완전히 다른 개념이므로 유의 하시기 바란다.

| 폭 | 설명 |
| - | - |
| * | 폭을 형식 문자열에 지정해서 받지 않지만, 그 대신에 형식 문자열 뒤에 오는 인자들에 넣어서 받는다. 이 때, 이는 정수 값이어야 하며 폭을 지정하는 변수 뒤에 출력할 데이터가 위치하면 된다. |

### 4. 정밀도

정밀도는 말그대로 수치 데이터를 출력할 때 어떠한 정밀도로 출력하는지 (즉, 몇 자리까지 출력해야 되는지)를 지정해준다. 참고적으로 정밀도를 나타낼 때, 앞에 꼭 마침표(.)을 찍는 것을 잊지 말기 바란다. 마침표를 찍는 이유는 앞에 폭과 구분을 하기 위해서이다.

| 정밀도 | 설명 |
| - | - |
| `.*` |  형식 문자열에서 정밀도를 나타내지는 않지만 뒤에 인자로 정밀도 값을 준다. 이 때 인자는 형식 태그가 적용되는 데이터 앞에 있어야 한다. |

### 5. 길이

길이는 출력하는 데이터의 정확한 크기를 지정하는데 사용된다. 예를 들어서 `%d` 서식문자의 경우 막연하게 `정수형 데이터를 십진법으로 출력한다`였지만 길이를 지정해주면 어떤 크기로 데이터를 출력해야되는지 (`int`인지 `short` 등등)을 지정할 수 있다.

| Conversion Specifier | Expected Argument Type | | | | | |
| - | - | - | - | - | - | - |
|   | hh | h | none | l | ll |
| c | N/A | N/A | int | wint_t | N/A |
| s | N/A | N/A | char* | wchar_t* | N/A |
| p | N/A | N/A | void* | N/A | N/A |
| d | signed char | short | int | long | long long |
| i | signed char | short | int | long | long long |
| u | unsinged char | unsigned short | unsigned int | unsigned long | unsigned long long |
| x | unsinged char | unsigned short | unsigned int | unsigned long | unsigned long long |
| X | unsinged char | unsigned short | unsigned int | unsigned long | unsigned long long |
| n | signed char* | short* | int* | long* | long long* |
| f | N/A | N/A | double | double | | |
| g | N/A | N/A | double | double | | |
| e | N/A | N/A | double | double | | |

## 3. ARGS?

함수는 다양한 타입의 다양한 어규먼트들로 불러질 수 있다. `stdarg.h` 을 선언하면 새로운 타입(`va_list`)을 만든다. 그리고 숫자와 타입이 정해지지 않은 아규먼트의 리스트를 통해서 3가지 매크로를 정의한다.

불러진 함수는 반드시 `va_start()`, `va_arg()`, `va_copy()` 와 `va_end()`를 통해서 사용되는 `va_list` 타입의 오브젝트를 선언해야한다.

`va_start()` 매크로는 반드시 먼저 불러야하고 그것은 진행할 각 어규먼트를 위한 `va_arg()`를 전달할 ap를 초기화한다. `va_end()`를 부르는 것은 더이상 어규먼트가 없다는 신호이고 `ap`가 유효하지 않게 한다. `va_start()`를 통한 각 콜은 같은 함수내에서 반드시 `va_end()` 콜에 매치되어야한다.

파라미터 `last`는 가변 아규먼트 리스트전에 마지막 파라미터의 이름이다. 예를 들어서, 마지막 파라미터는 함수를 부르는 것은 타입을 안다.

va_start() 매크로에서 이 파라미터의 주소가 사용된다. 그것은 반드시 레지스터 변수, 함수, 배열 타입으로 선언될 필요가 없다.

`va_arg()` 매크로는 콜에서 다음 어규먼트의 값과 타입을 가진 표현으로 확장된다. 파라미터 `ap`는 `va_start()`로 초기화되는 `va_list ap`이다. `va_arg()`를 향한 콜은 ap를 수정하고 그래서 다음 콜은 다음 어규먼트를 리턴한다. 파라미터 타입은 명시된 타입이름이고 그래서 오브젝트를 향한 포인터의 타입은 명시된 타입을 가지고 단순히 타입에 *을 추가하는 것으로 된다.

만약 다음 아규먼트가 없거나 만약 타입이 다음 아규먼트의 타입에 맞지 않으면 에러를 리턴한다.

`va_start()` 매크로 후의 `va_arg()` 매크로의 첫번째 사용은 `last`이후의 아규먼트를 리턴한다. 연속적인 혁신은 남은 아규먼트의 값을 리턴한다. `va_start()`의 두번째 아규먼트는 ...이전의 아규먼트를 받는다.

`va_copy()` 매크로는 가변 아규먼트 리스트의 상태를 복사한다. src 이전에 `va_start()`로 초기화된 것은, `va_start()`에 의해서 초기화된 것은 데스트. `va_end()` 콜에 개입없이. 데스트에 보존된 상태는 `va_start()`와 `va_arg()`를 부르는 것과 동일하다. 복사된 변수 아규먼트 리스트는 `va_arg()`에 연속적으로 패스되고 어쩌고 저쩌고 매뉴얼이 왤케 문장길고 단어 어렵냐.

`va_end()`에 의해서 가변 아규먼트 리스트가 비활성화되면, 그것은 `va_start()`에 의해서 다시 초기화되거나 `va_copy()`를 통해서 다른 가변 아규먼트 리스트로 초기화될 수 있다.

# 보너스 파트

- 만약 의무 파트가 완벽하지 않으면 보너스를 고려하지 말아라.

- 너는 모든 보너스를 할 필요가 없다.

- 다음과 같은 컨버전을 고려해라 : nfge

- 다음과 같은 플래그를 고려해라 : l ll h hh

- 다음과 같은 플래그를 관리해라 : # + (하나는 스페이스이다.)

