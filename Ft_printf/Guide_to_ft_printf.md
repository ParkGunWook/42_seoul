# 소개

c언어에서 프엪 함수의 다재다능함은 우리에게 프로그래밍을 위한 좋은 연습이 될 것이다. 이 프로젝트는 꽤나 어렵다. 그것은 너가 C에서 다재다능한 함수를 발견하는 것을 가능하게 해줄 것이다.
성공적인 **ft_printf**를 향한 키는 잘 구조화되어 있고 확장 가능한 좋은 코드이다.


# 공통 명세

- 너의 프로젝트는 반드시 Norm에 맞추어서 쓰여야한다. 만약 너가 보너스 파일/함수를 가지면, 그들은 놈에 체크되고 놈에 오류가 있다면 너는 0점을 받게 될 것이다.

- 너의 함수는 정의되지 않은 행동으로 인해서 비정상적으로 종료되지 않아야한다. 만약 그것이 일어나면, 너의 프로젝트는 작동하지 않는다고 고려되고 너는 평가동안에 0점을 받게 될 것이다.

- 힙메모리에 할당된 모든 공간은 필요할때 적절하게 해제되어야한다. 어떠한 릭도 허용되지 않는다.

- 만약 서브젝트가 필요로 하면, 너는 너의 소스 파일을 적절한 플래그로 컴파일해야하고 반드시 **Makefile**을 제출해야한다. 그리고 너의 메이크 파일은 반드시 리링크되지 않아야한다.

- 너의 메이크 파일은 반드시 $(NAME), all, clean, flcean, re를 가져야한다.

- 너의 프로젝트에서 보너스를 제출하면, 메이크 파일에 너는 bonus룰을 포함해야한다. 프로젝트의 메인 파트에서 허용되지 않은 모든 다양한 헤더, 라이브러리 또는 함수를 추가한다. 보너스는 반드시 다른 파일 _bonus.{c/h}안에 있어야한다. 의무와 보너스 파트 평가는 분리되서 실행된다.

- 만약 너의 프로젝트가 libft를 사용하게하면 너는 반드시 너의 소스를 복사하고 그것의 관련된 Makefile을 가져와야한다. 너의 프로젝트의 메이크 파일은 그것의 Makefile을 이용함으로서 라이브러리를 컴파일 해야하고, 프로젝트를 컴파일해야한다.

- 우리는 너가 너의 프로젝트에서 제출되지도 않고 채점되지도 않을 테스트프로그램을 생성하도록 독려한다. 그것은 너의 작업과 너의 동료의 작업을 쉽게 테스트할 기회를 줄 것이다. 너는 이런 테스트가 너의 디펜스에서 도움이 될 것이라는 것을 알 수 있다. 실제로, 디펜스하는 동안에, 너는 너의 테스트를 사용하거나 동료의 작업을 테스트할 때 도움될 것이다.

- 너의 작업물을 제공된 깃 레포에 작업해라. 오직 깃레포의 워크만이 채점된다. 만약 딥솟이 너의 작업을 채점하려고할당되면, 그것은 동료평가가 끝난 후일 것이다. 만약 에러가 너의 작업의 어떤 섹션에서 발생한다하면 평가는 멈춘다.

# 의무 파트

| | |
| - | - |
| 프로그램 명 | libftprintf.a |
| 제출 파일들 | \*.c \*/\*.c, \*/\*.h, Makefile |
| 외부 함수 | malloc, free, write, va_start, va_arg, va_copy, va_end |
| Libft 허용 | yes |
| 설명 | 실제 printf를 모방한 ft_printf를 포함한 라이브러리를 작성한다. |

- `ft_printf`의 프로토타입은 반드시 `int ft_printf(const char *, ...);`이다.

- 너는 반드시 `libc's printf` 함수를 리코딩해야한다.

- 그것은 실제 `printf`처럼 버퍼 관리를 하지 않아야한다.

- 그것은 다음과 같은 컨버전을 관리 해야한다. : cspdiuxX%(char, string, pointer)

- 그것은 다음과 같은 플래그를 처리해야한다. '-0.*', 그리고 모든 컨버전에 대해서 최소한의 필드 너비

- 그것은 실제 `printf`와 비교될 것이다.

- 너는 반드시 ar을 이용해서 너의 라이브러리를 만들어야한다.

> man 3 printf / man 3 stdarg

## 0. 프엪이란?
[출처 1](https://modoocode.com/35)

일련의 데이터를 특정한 형식에 맞추어 `stdout`에 출력한다.

표준 출력(stdout)에 일련의 데이터들을 형식 문자열(format)에 지정되어 있는 형태로 출력한다.

형식 문자열 다음에는 출력할 데이터들을 나열한다. `printf` 함수는 적어도 형식 문자열 속에 지정된 데이터 이상의 인자를 받기로 기대한다.

## 1. 인자

형식 문자열(format) 형식 문자열에는 `stdout`에 출력할 문자열이 들어있다.

이 때, 형식 문자열에는 형식 태그라 불리는 것이 추가적으로 들어갈 수 있는데, 이는 이에 대응하는 인자를 형식 태그가 지정한 형태로 치환되어 출력된다. 따라서 형식 문자열 다음으로 오는 인자들의 개수는 반드시 형식 문자열 속의 태그의 개수보다 같거나 많아야 한다.

형식 태그는 아래와 같은 꼴로 생겼다.

`%[플래그][폭][.정밀도][크기]서식 문자(specifier)`

### 1. 서식문자

| 서식 문자 | 출력 형태 | 예시 |
| - | - | - |
| c | 문자 | a |
| s | 문자열 | sample |
| p | 포인터 주소 | B800:0000|
| d | 부호 있는 십진법으로 나타난 정수 | 392 |
| i | 부호 있는 십진법으로 나타난 정수 | 392 |
| u | 부호없는 십진법으로 나타낸 정수 | 7235 |
| x | 부호없는 16 진법으로 나타낸 정수(소문자 사용) | 7fa |
| X | 부호없는 16 진법으로 나타낸 정수(대문자 사용) | 7FA |
| % | `%` 다음에 %를 또 붙이면 `stdout`에 `%`를 출력한다. | % |
| 보너스 | | |
| n | 아무것도 출력하지 않는다. 그 대신, 인자로 부호 있는 int 형을 가리키는 포인터를 전달해야 되는데, 여기에 현재까지 쓰여진 문자 수가 저장된다. | |
| f | 십진법으로 나타낸 부동 소수점 수 | 392.65 |
| g | %e나 %f 보다 간략하게 출력 | 392.65 |
| e | 지수 표기법으로 출력하되, `e` 문자를 이용한다. | 3.9265e+2 |

## 2. 플래그

형식 태그에는 위 말고도 플래그, 폭, .정확도, 제한자, 부-서식문자에 관련한 정보들이 포함될 수 있다. 먼저 플래그를 살펴보면 플래그는 기본적으로 출력되는 형태에 대해 조금 더 자세하게 지정할 수 있게 해준다. 플래그는 아래와 같다.

| 플래그 | 설명
| + | 출력 결과값이 양수인 경우라도 `+`기호를 앞에 붙여서 출력하도록 한다.(물론 음수면 자동적으로 `-`가 붙는다.) 기본적으로 지정하지 않았을 경우 음수에만 앞에 `-`가 붙는다. |
| 공백 | 앞에 부호가 붙지 않는다면 한 칸을 띄어서 출력한다. (다시말해 123은 " 123"으로 출력되고 -123은 "-123"으로 출력된다.) |
| # | `o, x, X` 서식 문자들과 사용되면 출력되는 값 앞에 각각 `0, 0x, 0X`가 붙게 된다.(이 때 0은 제외한다.) `e, E, f` 서식 문자들과 사용되면 소수점 아래 수들이 없음에도 불구하고 강제적으로 소수점을 붙이도록 한다. 원래 소수점 아래 수들이 없다면 소수점을 붙이지 않는다. `g`와 `G` 서식 문자들과 사용되면 `e` 와 `E` 일떄와 동일한 작업을 하지만 소수들의 뒷부분에 붙는 0들은 제거되지 않는다.
| 0 | 수들은 왼쪽으로 정렬하되 빈 칸을 삽입하는 대신에 0을 삽입한다.(폭 지정자 참조)

## 3. 폭

폭은 말그대로 출력되는 데이터의 폭을 지정해준다. 참고로 여기서의 폭(width)은 뒤에 나오는 길이(length)와는 완전히 다른 개념이므로 유의 하시기 바란다.

| 폭 | 설명 |
| * | 폭을 형식 문자열에 지정해서 받지 않지만, 그 대신에 형식 문자열 뒤에 오는 인자들에 넣어서 받는다. 이 때, 이는 정수 값이어야 하며 폭을 지정하는 변수 뒤에 출력할 데이터가 위치하면 된다. |

# 보너스 파트

- 만약 의무 파트가 완벽하지 않으면 보너스를 고려하지 말아라.

- 너는 모든 보너스를 할 필요가 없다.

- 다음과 같은 컨버전을 고려해라 : nfge

- 다음과 같은 플래그를 고려해라 : l ll h hh

- 다음과 같은 플래그를 관리해라 : # + (하나는 스페이스이다.)

