# 공동 목표

- 너의 프로젝트는 Norm에 맞추어서 작성되어야한다. 만약 너가 추가적인 파일/함수를 가지면, 그들은 놈 체크에 포함되고 norm error가 포함되면 0점을 받을 것이다.

- 너의 함수는 정의되지 않은 행동으로 인한 의도되지 않게 종료되어서는 안된다.(세그 폴트, 버스 에러, 더블 프리) 만약 이런 것들이 일어나면, 너의 프로젝트는 non functional로 0점을 받게 될 것이다.

- 메모리 공간에 할당된 모든 힙들은 필요할때 적절하게 해제되어야한다. 어떠한 리크도 허용되지 않는다.

- 만약 과제가 그것을 필요하면, 너는 반드시 너의 소스파일을 컴파일하는 Makefile을 제출해야한다. 그리고 flag들은 -Wall, -Wextra, -Werror로 컴파일될 것이다. 그리고 너의 Makefile은 반드시 relink되어서는 안된다.

- 너의 메이크파일은 반드시 $(NAME), all, clean, flcean, re를 포함해야한다.

- 너의 프로젝트에서 보너스를 받고싶으면, 너는 반드시 너의 Makefile에 bounus를 포함해야하고, 다양한 헤더, 라이브러리, 또는 함수를 위한 것들이 포함되어야한다. 보너스들은 다른 파일인 _bonus.{c/h}.에 포함되어야한다. 의무와 보너스 파트는 개별적으로 채점될 것이다.

- 만약 너의 프로젝트가 libft를 사용하게 하면, 너는 반드시 그것의 소스를 복사하고 그것의 관련된 libft 폴더내의 Makefile을 복사해야한다. 너의 프로젝트의 Makefile은 반드시 그것의 Makefile을 사용해서 만들어져야하고, 그후에 프로젝트는 컴파일 될 것이다.

- 우리는 너가 이 작업이 제출 되지 않고 채점되지 않는다해도 반드시 테스트 프로그램을 만들도록 장려한다. 그것은 너에게 너의 작업과 동료의 작업이 쉽게 채점될 찬스를 준다. 너는 너의 디펜스동안에 이것이 특히 유용하다는 것을 알 수 있다. 실제로, 디펜스 동안에, 너는 너의 테스트와 동료의 테스트를 사용하는 것이 자유이다.

- 너의 작업을 너에게 할당된 깃 레포에 제출해라. 깃 레포에 있는 작업만이 채점될 것이다. 만약 Deepthought가 너의 작업에 할당되면, 그것은 너의 동료 평가 이후일 것이다. 만약 에러가 너의 작업의 일부분 어딘가에서 일어나면, 채점은 중단될 것이다.

- 실행 파일은 반드시 `pipex`이어야 한다.

- 너는 반드시 에러를 예민하게 다뤄줘야한다. 만약 너의 프로그램이 예상치 못하게 종료해야한다.(세그 폴트, 버스 에러, 더블 프리 등등). 만약 너가 힘들면, 쉘 커맨드 < file1 cmd1 | cmd2 > file2 >와 같이 작동 시켜보아라.

- 너는 다음 함수를 사용할 수 있다.

	- open RMx
	- close RMx
	- read RMx
	- write RMx
	- malloc RMx
	- waitpid RMx
	- wait RMx
	- free RMx
	- pipe RMx
	- dup RMx
	- dup2 RMx
	- execve RMx
	- fork
	- perror
	- strerror
	- exit

# 목표

너의 목표는 파잎으 엑스 프로그램을 코딩하는 것이다.

이것과 같이 작동 해야한다.

```
$> ./pipex file1 cmd1 cmd2 file2
```

여기서 파일 1과 파일 2는 파일 이름들이고, cmd1과 cmd2는 그들의 파라미터를 가진 쉘 커맨드이다.

파이프엑스 프로그램의 실행은 다음 쉘 커맨드와 같다.
```
$> < file cmd1 | cmd2 > file2>
```

# 예시

```
$> ./pipex infile ``ls -l'' ``wc -l'' outfile
$> ./pipex infile ``grep a1'' ``wc -w'' outfile
```

다음과 같아야한다.

“< infile ls -l | wc -l > outfile”

“< infile grep a1 | wc -w > outfile”

# 새롭게 배우는 함수친구들

## waitpid

### include <sys/wait.h>

### 프로토 타입

pid_t waitpid(pid_t pid, int *stat_loc, int options);

### 설명

웨이트 함수는 **stat_loc** 정보가 종료된 자식 프로세스에 유효하거나 시그널을 받을때까지 그것을 부른 함수의 실행을 중단한다. 성공적인 **wait()** 콜을 리턴한 후에, **stat_loc** 영역은 밑에서 정의된 것처럼 종료 정보를 포함한다.

pid 파라미터는 기다리는 자식 프로세스의 집합을 특정한다. 만약 pid가 -1이면, 함수 콜은 자식 프로세서를 기다린다. 만약 pid가 0이면, 콜은 콜러의 프로세스 그룹안에 있는 어떠한 자식 프로세스도 기다린다. 만약 pid가 0이상이면, 콜은 프로세스 아이디 pid인 프로세스를 기다린다. 만약 pid가 -1보다 작으면, 콜은 pid의 절대값과 같은 그룹의 프로세스 번호를 기다린다.

**stat_loc** 파라미터는 아래에 정의된다. 옵션 파라미터는 비트와이즈 OR으로 된다. WNOHANG 옵션은 콜이 만약 상태를 보고하고자 하는 프로세스가 없을때 블럭하지 않는 역할을 가르킬때 사용한다. 만약 WUNTRACED 옵션이 있으면, 현재 프로세스의 자식은 SIGTTIN, SIGTTOU, SIGTSTP, 또는 SIGSTOP 시그널에 의한 것이다.

만약 **rusage**가 0이 아니면, 종료된 프로세스에 의해서 사용된 리소스의 요약과 모든 그것의 자식들이 리턴된다.


### 아무튼 옵션

- WIFEXITED
	프로세스가 exit(2) 또는 exit(3)에 의해서 정상적으로 종료되면 트루이다.
- WIFSIGNALED
	시그널의 receipt에 의해서 종료되면 트루이다.
- WIFSTOPPED
	만약 프로세스가 종료되지 않았으면 트루이지만, 정지하고 재시작될 수 있다.
	이 매크로는 만약 웨이트 콜이 WUNTRACED 옵션이 정의되거나 만약 자식 프로세스가 트레이스되면 트루이다.
- WEXITSTATUS
	만약 WIFEXITED가 트루이면, low order 8 bits가 자식에 의한 exit에 전달 된다.
- WTERMSIG
	만약 WIFSIGNALED가 트루이면, 프로세스의 종료에 의해서 생긴 시그널의 숫자를 측정한다.
- WCOREDUMP
	만약 WIFSIGNALED가 트루이면, 만약 프로세스의 종료가 프로세스의 이미지를 포함하는 코어파일의 생성이 동행되면 트루이다.
- WSTOPSIG
	만약 WIFSTOPPED가 트루이면, 멈출 프로세스에 의해서 생긴 시그널의 수를 측정한다.

### 노트

sigaction을 봐라, 터미네이션 시그널의 리스트이다. 0의 상태는 일반적인 종료를 알려준다.

만약 부모 프로세스가 자식 프로세스가 종료하기 전에 종료되면, 남은 자식 프로세스는 부모 프로세스 1 ID에 할당된다.

만약 시그널이 **wait()** 콜이 기다리면서 잡히면, 콜은 시그널 캐칭 루틴이 리턴할때 인터럽트되거나 리스타트 될 수 있고 시그널의 효과의 옵션에 달려있다.

### 리턴 값

만약 **wait()**가 멈추거나 종료된 자식 프로세스에 의해서 리턴되면, 자식의 프로세스 ID가 콜링 프로세스에게 리턴된다. 아니면 -1의 값이 리턴되고 errno가 리턴된다.

만약 **wait3(), wait4() or waitpid()**가 자식 프로세스의 종료에 의해서 리턴하면, 자식의 프로세스 아이디가 콜링 프로세스에게 리턴된다. 만약 차일드가 없으면, -1이 리턴되고 에러너가 [ECHILD]로 세팅된다. 다른 경우에는, 만약 WNOHANG가 정의되어있고 멈추거나 나가는 자식이 없어도 0이 리턴된다. 만약 에러가 잡히거나 콜을 어보트하는 시그널을 잡으면, -1의 값이 생기고 에러너가 잘 정의된다.

### 에러들

- [ECHILD]
	콜링 프로세스가 자식 프로세스가 없다.
- [EFAULT]
	status 또는 rusage 어규먼트가 부정확한 주소를 가르킨다.(자식 프로세스의 탈출 이전에 찾지 못할 수 도 있다.)
- [EINVAL]
	옵션 어규먼트에 이상한게 드갔다.
- [ECHILD]
	pid에 의해서 정의된 프로세스가 정의되있지 않거나 콜링 프로세스의 차일드가 아니거나 그룹이 아니거나 콜링프로세스의 차일드가 없다.
- [EINTR]
	콜이 잡은 시그널에 의해서 인터럽트 되거나 시그널이 SA_RESTART 플래그가 없다.


## pipe

### #include <unistd.h>

### int pipe(int fildes[2]);

### 설명

**pipe()** 함수는 파이프(단방향 데이터 플로우의 흐름을 허용하는 오브젝트)를 생성하고 파일 디스크립터의 쌍을 할당한다. 첫번째 디스크립터는 파이프의 리드엔드에 연결된다. 두번쨰는 라이트 엔트에 연결된다.

filedes[1]에 쓰인 데이터는 fildes[0]에서 생긴다. 이것은 하나의 프로그램이 다른 프로그램에 보내질 아웃풋을 허용한다. 소스의 스탠다드 아웃풋은 파이프의 라이트 엔드가 되도록 셋된다. 싱크의 스탠다드 인풋은 파이프의 리드 엔드에 연결된다. 파이프 자체는 그것의 모든 연결된 것들이 될떄까지 작동한다.

리드 또는 라이트엔드가 종료된 파이프는 **widowed**라고 한다. 이런 파이프에 쓰는 것은 SIGPIPE 시그널을 넘겨준다. 파이프 한쪽만 남기는 것은 한가지 리드만 되고 리더가 어떠한 데이터 버퍼를 쓰고나서 남은 위도우된 파이프는 0을 리턴한다.

SIGPIPE 신호의 생성은 어떠한 짓을 통해서 억누를 수 있다.

### 리턴 값

성공적인 파이프의 생성은 0을 리턴한다. 다른 경우에는, -1의 값이 리턴되고 에러를 말한다.

### 에러

- [EFAULT]
	fildes 버퍼가 프로세스의 주소에 이상한 공간에 있다.
- [EMFILE]
	너무 많은 디스크립터들이 활동중이다.
- [ENFILE]
	시스템 파일 테이블이 꽉찼당.


## dup dup2

### #include <unistd.h>

### int dup(int fildes);

### int dup2(int fildes, int fildes2);

### 설명

**dup()**은 존재하는 오브젝트 디스크립터를 복제하고 그것의 값을 콜링 프로세스에 리턴한다. 어규먼트 fildes는 작은 양수 인티저 인덱스이다. 값은 반드시 테이블의 사이즈보다 작아야한다. gettablesize를 잘 써보자. 새로운 디스크립터는 콜에 의해서 리턴되고 프로세스에 의해서 사용되지 않는 가장 작은 숫자이다.

디스크립터에 의해서 레퍼런스되는 오브젝트는 fildes와 fildes2사이에서 구별되지 않는다. 그러므로 만약 두개가 같으면 레퍼런스사이에서 곱창난다. 만약 분리된 포인터가 파일안에서 소망되면, 다른 오브젝트를 오픈을 통해서 한다. 실행중 종료 플래그는 언셋이다.

**dup2()**에서, 새로운 디스크립터 fildes2의 값이 정의되어있다. 만약 두개가 같으면 dup2는 단순히 fildes2만 리턴한다. 존재하는 디스크립터에 아무런 일도 안생긴다. 만약 디스크립터 fildes2가 이미 사용중이면 그것은 close콜이 불린 것 처럼 할당해제된다.

### 리턴 값

성공적인 이후에, 새로운 파일 디스크립터가 리턴된다. 다른 경우에, -1의 값이 리턴되고 에러너가 설저오딘다.

### ERRORS

- [EBADF]
	파일디스크립터가 액티브 하지 않다.
- [EINTR]
	시그널에 의해서 실행이 죽쒔다.
- [EMFILE]
	너무 많은 파일 디스크립터가 있다.
- [EBADF]
	fildes2가 네거티브이고 너무 큰 값이다.

## EXECVE

### #include <unistd.h>

### int execve(const char *path, char *const argv[], char *const envp[])

### 설 명.

**execve()**는 콜링 프로세스를 새로운 프로세스로 변형시킨다. 새로운 프로세스는 일반적인 파일에 의해서 생성된다. 그 이름은 **path**로 포인트되고 새로운 프로세스 파일을 부른다. 이 파일은 실행가능한 오브젝트 파일이거나 인터프리터의 파일이다. 실행가능한 오브젝트 파일은 구별 헤더의 파일에 의해서 포함된다. 데이터의 페이지에 의해서 따라온다. 추가적인 페이지는 0 데이터에 의해서 초기화된다.

인터프리터 파일은 폼의 라인과 함께 시작된다.

#! interpreter [arg ...]

인터프리터 파일이 execve()되면, 시스템은 특정한 인터프리터를 실행한다. 만약 옵셔널 args가 정의되면, 그들은 첫번째, 인터프리터를 아규먼트이다. execve()

어규먼트 argv는 눌로 끝나는 캐릭터 스트링의 눌로 종료되는 어레이의 포인터이다. 이러한 스트링들은 새로운 프로세스에 가용한 어규먼트 리스트를 만든다. 최소한 하나의 어규먼트가 어레이엥 있으면 첫번째 요소는 실행되는 프로그램의 이름이다.(패스의 마지막 컴포넌트)

어규먼트 **envp**는 또한 눌 터미네이트 스트링의 눌 터미네이트 어레이의 포인터이다. 이 행렬의 포인터는 전역 변수인 environ 에 저장된다. 이러한 스트링들은 새로운 프로그램에 넘겨진다.

콜링 프로세스 이미지 안의 파일 디스크립터 오픈은 새로운 프로세스 이미지에 남는다. 물론 close-on-exec 플래그셋이 되면 얘기가 다르다. execve()에 의해서 생긴친구들은 여전히 남는다.

콜링 프로세스 안의 무시되기로한 시그널은 새로운 프로세스 안에서 이그노어되기로 세팅된다. 콜링 프로세스 이미지 안에서 잡힌 시그널은 새로운 프로세스 이미지 안에서 디폴트 액션으로 세팅된다. 막힌 시그널은 시그널 액션의 변화에 관련없이 블럭된다. 시그널 스택은 정의되지 않기로 리셋된다.

만약 셋 유저 아이디 모드 비트가 있으면(chmod), 유효한 유저의 아이디가 새로운 아이디에 된다. 나머지도 비슷할듯하다.

### 리턴 값

execve()함수는 현재 프로세스 이미지를 오버레이한다. 새로운 프로세스 이미지로, 성공적인 콜은 리턴할 프로세스가 없는 것이다. 만약 함수가 콜링 프로세스를 리턴하면 에러가 생긴 것이다. 리턴한 값은 -1이고 전역 변수로 뭐라할 것이다.

### 에러들

- E2BIG
	새로운 프로세스의 아규먼트 리스트안의 바이트의 수가 시스템 내부 리미트보다 크다. 이 리미트는 sysctl에서 KERN_ARGMAX 변수에서 볼수 있을 것.
- EACCES
	패스 프리픽스의 권한에서 막힘
- EACCES
	새로운 프로세스 파일이 일반적인 파일이 아님
- EACCES
	새로운 프로세스 파일이 권한이 개같음
- EACCES
	새로운 프로세스 파일이 실행이 불가능한 상태임
- EFAULT
	새로운 프로세스 파일이 이상함
- EFAULT
	새로운 프로세스 파일이 더이상 안됨
- EIO
	아이오 에러가 생겼음
- ELOOP
	너무 많은 심벌릭 링크를 만나서 이상해짐
- ENAMETOOLONG
	패스 이름의 컴포넌트가 네임 맥스 캐릭터를 넘김
- ENOENT
	새로운 프로세스 파일이 존재 않함
- ENOEXEC
	새로운 프로세스 파일이 적절한 엑세스 퍼미션을 안가짐
- ENOMEM
	새로운 프로세스가 가상메모리를 맥시멈보다 더가짐
- ENOTDIR
	패스의 프리픽스가 디렉토리가 아임
- ETXTBSY
	새로운 프로세스 파일이 순수한 프로시저 파일임


	https://linuxhint.com/using_pipe_function_c_language/