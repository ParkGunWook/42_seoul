# 서두

게임만들기를 해보자.
그러나 좋은 게임을 위해서는 좋은 자산이 필요하다.
2D게임을 위해서, 너는 타일, 타일셋, 스프라이트, 스프라이트 시트가 필요할 것이다.
감사히도 몇몇의 재능있는 아티스트들은 그들의 작업을 공유해두었다.

[게임 자료](https://itch.io/game-assets/free/tag-sprites)

# 목표

프로젝트의 목적은 첫번쨰 목표와 같다. 엄격하고 C의 사용, 간단한 알고리즘, 정보 개발 등등

그래픽 디자인 프로젝트, 소롱은 윈도우, 컬러, 이벤트, 질감 등등의 영역을 다루게 해줄 것이다.

# 공통 목표

- 너의 프로젝트는 Norm에 맞추어서 작성되어야한다. 만약 너가 추가적인 파일/함수를 가지면, 그들은 놈 체크에 포함되고 norm error가 포함되면 0점을 받을 것이다.

- 너의 함수는 정의되지 않은 행동으로 인한 의도되지 않게 종료되어서는 안된다.(세그 폴트, 버스 에러, 더블 프리) 만약 이런 것들이 일어나면, 너의 프로젝트는 non functional로 0점을 받게 될 것이다.

- 메모리 공간에 할당된 모든 힙들은 필요할때 적절하게 해제되어야한다. 어떠한 리크도 허용되지 않는다.

- 만약 과제가 그것을 필요하면, 너는 반드시 너의 소스파일을 컴파일하는 Makefile을 제출해야한다. 그리고 flag들은 -Wall, -Wextra, -Werror로 컴파일될 것이다. 그리고 너의 Makefile은 반드시 relink되어서는 안된다.

- 너의 메이크파일은 반드시 $(NAME), all, clean, flcean, re를 포함해야한다.

- 너의 프로젝트에서 보너스를 받고싶으면, 너는 반드시 너의 Makefile에 bounus를 포함해야하고, 다양한 헤더, 라이브러리, 또는 함수를 위한 것들이 포함되어야한다. 보너스들은 다른 파일인 _bonus.{c/h}.에 포함되어야한다. 의무와 보너스 파트는 개별적으로 채점될 것이다.

- 만약 너의 프로젝트가 libft를 사용하게 하면, 너는 반드시 그것의 소스를 복사하고 그것의 관련된 libft 폴더내의 Makefile을 복사해야한다. 너의 프로젝트의 Makefile은 반드시 그것의 Makefile을 사용해서 만들어져야하고, 그후에 프로젝트는 컴파일 될 것이다.

- 우리는 너가 이 작업이 제출 되지 않고 채점되지 않는다해도 반드시 테스트 프로그램을 만들도록 장려한다. 그것은 너에게 너의 작업과 동료의 작업이 쉽게 채점될 찬스를 준다. 너는 너의 디펜스동안에 이것이 특히 유용하다는 것을 알 수 있다. 실제로, 디펜스 동안에, 너는 너의 테스트와 동료의 테스트를 사용하는 것이 자유이다.

- 너의 작업을 너에게 할당된 깃 레포에 제출해라. 깃 레포에 있는 작업만이 채점될 것이다. 만약 Deepthought가 너의 작업에 할당되면, 그것은 너의 동료 평가 이후일 것이다. 만약 에러가 너의 작업의 일부분 어딘가에서 일어나면, 채점은 중단될 것이다.

# 필수 파트 - 소롱

| | |
| - | - |
| 프로그램 명 | 소롱 |
| 제출 파일 | 전부다 |
| 메이크 파일 | all, clean, fclean, re, bonus |
| 어규먼트 | 포맷 *.ber의 맵 |
| 외부 함수 | open, close, read, write, malloc, free, perror, stderror, exit |
| | MinilbX의 모든 함수 |
| 맆엪 | 허용 |
| 설명 | 너는 돌고래가 생선을 먹고 도망치는 작은 2D게임을 만들 것이다. 또는 어떤 히어로가 중요한 것들을 모으고 공간을 떠난다. |

제한 사항은 다음과 같다.

- 너는 반드시 miniLibX를 사용해야한다. 또는 운영체제에 맞는 버전을 쓴다. 만약 너가 소스를 바탕으로 사용하면, 너는 맆엡도 똑같아야한다.

- 너의 윈도우의 관리는 스무스해야한다. 다른 윈도우로의 전환, 최소화 등이다.

- 돌핀으로 예시가 주어지지만 너는 원하는 테마를 맘껏 쓸 수 있다.

- 맵은 3가지 요소로 구성된다. 벽, 콜렉션, 빈공간

- 플레이어의 목표는 맵상에 존재하는 모든 수집품을 모으고 최소한의 움직임으로 도망치는 것이다.

- 모든 움직임마다 움직임의 현재 숫자를 쉘에 표현해야한다.

- 플레이어는 반드시 위, 아래, 옆, 옆으로 이동할 수 있어야한다.

- 너는 탑다운 뷰를 사용할 것이다.

- 게임은 리얼타임일 필요가 없다.

- 플레이어는 벽뚫이 되지 않는다.

- 프로그램은 윈도우에서 이미지를 표현하고 다음 룰을 존중한다.
	- W A S D가 메인 캐릭터 움직임을 담당한다.
	- ESC를 누르면 윈도우를 닫고 프로그램을 깔끔하게 나간다.
	- 윈도우의 프레임에서 레드 크로스를 클릭하면 윈도우를 닫고 프로그램이 깔끔하게 종료된다.
	- 미니 엘아이비엑스의 이미지의 사용이 크게 추천된다.

- 너의 프로그램은 .ber이라는 확장자명을 가진 맵 상세 파일을 봐야한다.
	- 맵은 반드시 5가지 가능성을 포함한다. : 0은 빈공간, 1은 벽, C는 콜렉션, E는 맵의 출구, P는 플레이어의 스타팅 포지션이다.
	- 맵은 벽으로 둘러싸여있고 닫혀있어야하만한다. 그렇지 않으면, 프로그램은 에러를 리턴한다.
	- 맵은 반드시 하나의 출구, 하나의 고기, 하나의 시작 포인트를 가져야한다.
	- 너는 맵에 유효한 길이 있는지 체크할 필요는 없다.
	- 맵은 반드시 직사각형이어야한다.
	- 너는 반드시 어떤 종류의 맵을 파싱할 수 있어야한다.
	- 만약 파일에서 어떤 문제가 생기면, 프로그램은 반드시 종료를 하고 에러를 리턴해야한다. 그것은 너의 선택에 따라서 정확한 에러메시지를 출력한다.(Error가 마지막에 붙는)

# minilibx 매뉴얼 페이지

# man minilibx_mms_20200219/man/man3/mlx.3

## 이름

Minilibx - 42학생들을 위한 단순한 윈도우 인터페이스 라이브러리

## 시놉시스

`#include <mlx.h>`
`void *mlx_init();`

## 설명

미니라이브러리엑스는 그래픽 소프트웨어를 만드는 가장 쉬운 방법이다. 윈도우 프로그래밍 상식없이 너는 구현할 수 있다. 그것은 윈도우 생성, 그림 툴, 이미지와 기본 이벤트 관리를 돕는다.

## 유닉스/리눅스 : X 윈도우 컨셉

X 윈도우는 유닉스를 위한 네트워크 기반 그래픽 시스템이다. 그것은 두가지 메인 파트를 기반한다. 한가지는, 너의 시스템이 스크린 위에 무언가를 그리기를 원하거나 키보드와 마우스 엔트리를 얻는다. 다른 측면에서는, X-server가 스크린을 관리하고 키보드와 마우스를 관리한다. 네트워크 연결은 반드시 이 두 엔티티를 통해서 연결되고 그리는 순서를 보낸다.(소프트웨어에서 X서버로) 그리고 마우스/키보드 이벤트(X서버에서 소프트웨어로)
오늘날, 대부분의 시간에서, 같은 컴퓨터에서 작동한다.

## 맥 오에스 : 윈도우 서버 와 지피유

너의 소프트웨어는 다른 소프트웨어와 이벤트 시스템과 함께 스크린에서 동거를 관리하는 윈도우 서버와 소통하고, 모든 그림 스텊을 관리하는 지피유와 통신한다.

## 인클루드 파일

엠엘엑스.h는 미니엘아이비엑스 에이피아이의 정확한 사용을 위해서 포함한다. 그것은 오직 함수 프로토타입을 포함하고 있고, 구조체가 필요하지 않다.

## 라이브러리 함수

먼저, 너는 소프트웨어와 디스플레이의 연결을 초기화할 필요가 있다. 이 연결이 성립되면, 너는 미니엘아이비엑스 함수를 사용할 수 있어지고 디스플레이로부터 메시지를 받을 수 있다. 나는 윈도우에 노란색 픽셀을 가지고 싶어, 유저가 키를 눌렀어?

**mlx_init** 함수는 이 연결을 만들어 낼 것이다. 파라미터는 필요하지 않고 그것은 보이드 포인터 식별자를 리턴한다. 이 식별자는 라이브러리 루틴을 호출하기 위해서 사용된다.

모든 다른 미니엘아이비엑스 함수는 다음 맨 페이지들에 소개된다.

- **mlx_new_window** : 윈도우를 관리한다.
- **mlx_pixel_put** : 윈도우 내부를 그린다.
- **mlx_new_image** : 이미지를 관리한다.
- **mlx_loop** : 키보드 또는 마우스 이벤트를 관리한다.

## 링킹 미니엘아이비엑스

미니엘아이비 엑스 함수를 사용하기 위해서, 너는 소프트웨어에 몇가지 라이브러리를 링크할 필요가 있다. 유닉스/리눅스에서, 단순히 다음 아규먼트를 링킹시간에 추가하면 된다.

**-lmlx -lXext -lX11**

맥에서 다이나믹 메탈 라이브러리를 찾을 것이다.

**-lmlx**
맥에서 정적 오픈지엘 버전을 필요로 할 것이다.

**-lmlx -framework OpenGL -framework Appkit -lz**
너는 -L 플래그로 링크를 명시해주어야한다.

## 리턴값

**mlx_init()**이 디스플레이 연결을 실패하면, 그것은 널값을 리턴하거나 다른 경우에는 널 포인터가 연결 식별자에 리턴된다.

# man mlibx new window

## 시놉시스

`void *mlx_new_window(void *mlx_ptr, int size_x, int size_y, char *title);`
`int mlx_clear_window(void *mlx_ptr, void *win_ptr);`
`int mlx_destroy_window(void *mlx_ptr, void *win_ptr);`

## 설명

`mlx_new_window()` 함수는 새로운 윈도우를 스크린에 띄우고, 사이즈 파라미터를 통해서 그것의 사이즈를 결정한다 그리고 타이틀은 윈도우의 타이틀 바 위에서 보여진다. mlx_ptr 파라미터는 mlx_init()에서 리턴되는 값이다. `mlx_new_window()`는 보이드 포인터 윈도우 식별자를 리턴하고 다른 미니립스 콜에 의해서 사용된다. 미니 립엑스는 임의의 숫자의 분리된 윈도우를 관리할 수 있다.

`mlx_clear_window()`와 `mlx_destroy_window()`는 각각 주어진 화면을 부수고 클리어한다. 그들은 둘다 같은 파라미터를 가진다. `mlx_ptr`은 스크린 연결 식별자이고 `win_ptr`은 윈도우 식별자이다.

## 리턴 값

만약 `mlx_new_window()`가 새로운 윈도우를 만드는 것에 실패하면, 그것은 널을 리턴한다. 다른 경우에는 널이 아닌 포인터를 mlx window 식별자로서 리턴한다. `mlx_clear_window`와 `mlx_destroy_window`는 둘다 아무것도 리턴하지 않는다.

# mlx mlibx pixel put

## 시놉시스

`int mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);`
`int mlx_string_put(void *mlx_ptr, void *win_ptr, int x, int y, int color, char *string);`

## 설명

`mlx_pixel_put()` 함수는 정의된 픽셀을 win_ptr을 사용해서 그린다. 원점인 (0, 0)은 좌상단이다. 그리고 증가하면서 우 하단으로 간다. 물론 커넥션 식별자인 mlx_ptr이 필요하다.

`mlx_string_put()` 함수도 같다. 픽셀대신에 특정한 스트링은 x, y에 주어질 것이다.

두 함수 모두 윈도우 밖을 버린다??. 이것이 `mlx_pixel_put`을 느리게한다. 이미지를 사용해보자.

## 컬러 관리

컬러 파라미터는 인티저 타입이다. 보여지는 컬러는 이 정수로 인코드된다. 모든 보여지는 컬러는 3가지 베이직 컬러로 나뉘는데, 빨, 초, 파이다. 3가지는 0~255의 범위를 가진다. 이런 세가지 값은 정확한 색을 보이기 위해서 정수에 들어간다. 3바이트가 색으로 채워진다.(lsb)
인티저를 채우는 동안에, 너는 엔디안 문제를 확실히 해결해라. 블루가 항상 가장 최소비트이다.

하드웨어에 따라서, 가장 큰 비트는 투명도를 조절한다. 조심해라, 오픈지엘 클래식의 반대에서, 그것은 오파시티가 아니다.

# mlx mlibx new image

## 시놉시스

`void *mlx_new_image(void *mlx_ptr, int width, int height);`
`char *mlx_get_data_addr(void *img_ptr, int *bits_per_pixel, int *size_line, int *endian);`
`int mlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y)`
`unsigned int mlx_get_color_value(void *mlx_ptr, int color);`
`void *mlx_xpm_to_image(void *mlx_ptr, char **xpm_data, int *width, int *height)`
`void *xpm_file_to_image(void *mlx_ptr, char *filename, int *width, int *height)`
`void *png_file_to_image(void *mlx_ptr, char *filename, int *width, int *height)`
`int mlx_destroy_image(void *mlx_ptr, void *img_ptr)`

## 설명

`mlx_new_image`는 메모리안에서 새로운 이미지를 생성한다. 그것은 보이드 포인터 식별자를 리턴한다. 이것은 이미지를 조절하는데 쓰인다. 그것은 오직 만들 이미지의 사이즈만 필요하다. 엠엘엑스 포인터는 당연히 필요하다.

유저는 이미지내부를 그릴수 있고 특정 윈도우에 원할때 마다 이미지를 덤프할 수 있다. 이것은 `mlx_put_image_to_window`로 실현된다. 세개의 식별자가 여기서 필요하다. 디스플레이에 연결, 윈도우가 쓸것, 이미지(각각 mlx_ptr, win_optr, img_ptr) x,y는 이미지가 어디에 있을지 이다.

`mlx_get_data_addr()`은 생성된 이미지에 관한 정보를 리턴하고, 유저가 그것을 수정하게 허용한다. `img_ptr`파라미터는 사용할 이미지를 특정한다. 3가지 파라미터가 있다. bits_per_pixel은 비트의 숫자에 맞게 채워지고 특정한 색을 의미한다.(이미지의 뎁스라고도 불린다.) `size_line`은 바이트의 수이고 메모리에 이미지의 라인을 저장한다. 이 정보는 이미지에서 한가지 라인에서 다른 라인으로 이동할 때 필요하다. `endian`은 너가 이미지안의 픽셀 컬러를 리틀로할지 빅으로할지 정한다.(리틀은 0, 빅은 1)

`mlx_get_data_addr()`은 `char *` 주소를 리턴한다. 이미지가 저장된 메모리 영역의 시작을 말한다. 이 주소로부터, 첫번째 `bits_per_pixel` 비트는 이미지의 첫 줄의 첫 픽셀의 수를 대표한다. `bits_per_pixel`의 두번째 그룹은 첫 라인의 두번째 픽셀을 대표한다. `size_line`을 향한 주소는 두번째 라인의 시작을 찾기위해서 추가한다. 너는 이미지에 맘껏 도달할 수 있을 것이다.

`mlx_destroy_image`는 주어진 이미지를 부순다.

## 이미지안에 컬러를 저장하기

디스플레이에 따라서, 픽셀을 저장하는 비트의 숫자는 바뀐다. 유저는 보통 RGB모드로 컬러를 대표하고, 하나의 바이트로 각 컴포넌트를 사용한다. 이 것은 반드시 이미지의 필요를 `bits_per_pixel`에 맞춰야한다. 이것이 `mlx_get_color_value`의 역할이다. 그것은 표준 RGB 컬러 파라미터를 받아서 인트 값으로 리턴한다. 피트 퍼 픽셀은 lsb의 값이 이미지에 저장되어있다. 너는 이 함수를 사용해서 만약 컨버전을 피할 수 있다.

lsb는 컴퓨터의 엔디안에 맞춰져있는 것을 명심해라, 만약 이미지의 엔디안이 다르면, 사용되기전에 이상해 질 수 있다.

## XPM, PNG 이미지

`mlx_xpm_to_image()`, `mlx_xpm_file_to_image`, `mlx_png_file_to_image`함수는 새로운 이미지를 같은 방법으로 만들어 낼 것이다. 그들은 특정한 xpm_data또는 파일 이름으로 채운다. 미니 엘아비엑스는 표준 Xpm과 png라이브러리를 사용하지 않는다. 너는 두 타입의 이미지를 모조리 읽지는 못할 것이다.

## 리턴값

실패하면 항상 널포인터를 준다.

# man mlx_loop

## 시놉시스

`int mlx_loop(void *mlx_ptr);`
`int mlx_key_hook(void *win_ptr, int (*funct_ptr)(), void *param)`
`int mlx_mouse_hook(void *win_ptr, int (*funct_ptr)(), void *param)`
`int mlx_expose_hook(void *win_ptr, int (*funct_ptr)(), void *param)`
`int mlx_loop_hook(void *win_ptr, int (*funct_ptr)(), void *param)`

## 이벤트

그래피 시스템은 양방향이다. 한 쪽에서는, 프로그램은 스크린에 픽셀을 표시하기 위해서 명령을 전달하고 반대편에서는, 그것은 키보드와 마우스의 동작을 스크린에 보낸다. 이를 위해서, 프로그램은 키보드 또는 마우스로부터 이벤트를 받는다.

## 설명

이벤트를 받기위해서 너는 반드시 `mlx_loop()`를 사용해야한다. 그것은 리턴하지 않는다. 그것은 이벤트를 기다리면서 무제한 루프를 돌린다. 그리고 유저가 정의한 함수를 만든다.

너는 다른 함수를 3가지 이벤트로 할당한다.

- 키가 눌러짐.
- 마우스 버튼이 눌려짐
- 윈도우의 일부분이 다시 그려짐(이것이 "expose" 이벤트이고, 맥은 걱정 없다.)
- `mlx_key_hook`, `mlx_mouse_hook`, `mlx_expose_hook`은 정확히 같은 동작을 한다. `func_ptr`은 너가 이벤트가 발생했을때 원하는 함수이다. 이 할당은 윈도우 피티얼에 의해서 정의된다. `parma` 주소는 불려오는 모든 함수를 패스하고 필요한 파라미터를 저장하기 위해서 사용된다.

`mlx_loop_hook` 함수는 이전과 같은데, 그것은 이벤트 없이도 생긴다.

어떤 이벤트를 잡을때 립엑스는 다음의 고정된파라미터를 찾는다.

- `expose_hook(void *param);`
- `key_hook(int keycode, void *param);`
- `mouse_hook(int button, int x, int y, void *param);`
- `loop_hook(void *param);`

이런 함수 이름은 아비터리하다. 그들은 이벤트에 따라서 파라미터를 구별하기 위해서 사용된다. 이런 함수들은 미니립엑스의 일부분은 아니다.

파람은 훅 콜에 정의된 주소이다. 이 주소는 사용되지 않는다. 키와 마우스 이벤트일때, 추가적인 정보가 넘겨진다. 키코드는 어떤 키가 눌렸는지 이다.(x11과함꼐, 인클루드 파일 `keysmdef.h`를 살펴봐라), (x, y)는 윈도우에서의 마우스의 좌표이다. 그리고 버튼은 어떤 버튼이 눌렸는지이다.

## 더 많은 이벤트

미니립엑스는 다른 존재하는 이벤트에 대해서 더욱 제너릭한 것을 제공한다. mlx.h는 mlx_hook()을 제공한다. 이벤트와 마스크 값은 X11의 x.h에서 가져왔다. 몇몇 MacOS이벤트 들은 이런 값에 매핑되어있다. 그것이 말이되면, 마스크는 MacOS에서 결코 사용되지 않는다.

소스코드를 좀봐라.

[볼 수 있을까?](https://tronche.com/gui/x/xlib/)