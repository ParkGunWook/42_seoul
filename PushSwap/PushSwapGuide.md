# What is PushSwap

## 소개

**Push_swap** 프로젝트는 매우 단순하고 효과적인 알고리즘 프로젝트이다. 데이터는 정렬되어야한다.
너는 인트 값의 셋, 2개의 스택 그리고 두 스택을 조정하는 인스트럭션의 셋을 가진다.

너의 목표는? push_swap을 부르는 c 프로그램을 만든다.
받은 정수 어규먼트를 정렬하는 명령어 언어를 **Push_swap**을 이용해서 정렬하고 표준 출력을 준다.

## 목표

코더의 인생에서 소팅 알고리즘은 매우 중요한 스텝이다. 왜냐하면 그것은 보통 복잡도에 관한 개념을 배우기 때문이다.

소팅 알고리즘, 그리고 그들의 복삽성은 잡 인터뷰에서 자주 언급되는 클래식한 질문의 일부이다.
너는 이 컨셉을 보는 것이 중요한데 그들을 언젠가는 마주할 것이기 때문이다.

이 프로젝트에서 배울점은 C의 사용, 엄격함, 기본 알고리즘의 사용이다. 특히 이러한 베이직 알고리즘의 복잡성을 보게될 것이다.

값 정렬은 단순하다. 그들을 가장 빠르게 정렬하는 방법은 덜 심플한데, 특히 인티저의 상태에 따라서, 가장 효과적인 소팅 알고리즘은 다르다.

## 기본 요구사항

- 프로젝트는 사람이 한다. 너는 너의 파일을 너가 원하는대로 구성하면된다. 비록 너는 밑의 요구사항은 만족해야한다.
- 실행 파일의 이름은 **push_swap**이다.
- 너는 **Makefile**을 제출해야한다. **Makefile**은 프로젝트를 컴파일할 필요가 있고 반드시 일반적인 룰을 만족해야한다.
    그것은 만약 필요하다면 리컴파일 할 수 있어야한다.
- 만약 너가 영리하면, 너는 이 프로젝트를 위해서 맆엪을 사용할 수 있다. 너의 메이크 파일은 라이브러리를 컴파일해야하고,
    너의 프로젝트를 컴파일 해야한다.
- 전역변수는 금지된다.
- 너의 프로젝트는 반드시 Norm에 맞춰서 C로 쓰여야한다.
- 너는 에러를 예리하게 잡아야한다. 예측하지 못한 결과로 프로그램이 종료되어서는 안된다.
- 릭은 절대 안된다.
- 다음 함수들이 허용된다.
  - write
  - read
  - malloc
  - free
  - exit

## Mandatory part

- 게임은 a와 b라는 이름의 두개의 스택으로 구성된다.
- 시작하기에 앞서서:
  - 중복없이 양수 또는 음수를 가져야한다.
  - b는 비어있다.
- 목표는 스택 a에서 오름차순으로 정렬하는 것이다.
- 이것을 행하기 위해서 다음의 operation이 있어야한다.
    - sa : swap a - 스택 a의 탑의 첫번쨰 2 엘리먼트를 스왑한다. 만약 하나 또는 엘리먼트가 없으면 실행하지 않는다.
    - sb : swap b - 스택 b의 탑의 첫번쨰 2 엘리먼트를 스왑한다. 만약 하나 또는 엘리먼트가 없으면 실행하지 않는다.
    - ss : sa와 sb를 동시에 실행한다.
    - pa : push a - b의 탑을 가지고 그것을 a에 둔다. b가 비어있으면 아무 것도 실행하지 않는다.
    - pb : push b - a의 탑을 가지고 그것을 b에 둔다. a가 비어있으면 아무 것도 실행하지 않는다.
    - ra : rotate a - a의 모든 엘리먼트를 쉬프트 업한다 첫번째 엘리먼트가 마지막 엘리먼트가 된다.
    - rb : rotate b - b의 모든 엘리먼트를 쉬프트 업한다 첫번째 엘리먼트가 마지막 엘리먼트가 된다.
    - rr : ra와 rb를 동시에 실행한다.
    - rra : reverse rotate a - a의 모든 엘리먼트를 쉬프트 다운한다. 마지막 엘리먼트가 첫번쨰 엘리먼트가 된다.
    - rrb : reverse rotate b - b의 모든 엘리먼트를 쉬프트 다운한다. 마지막 엘리먼트가 첫번째 엘리먼트가 된다.
    - rrr : rra와 rrb를 같은 시간에 실행한다.

## 예시

위의 명령어들의 효과를 설명하기 위해서, 인티저의 랜덤리스트를 소팅해보겠다. 이 예시에서, 우리는 두개의 스택을
오른쪽에서부터 증가시키겠다.

```commandline
Init a and b:
2
1
3
6
5
8
- -
a b
-------------------------------------------------
Exec sa:
1
2
3
6
5
8
- -
a b
위의 예시를 통해서 sa는 1, 2가 탑에 존재한다고 알 수 있다.
-------------------------------------------------
Exec pb pb pb:
6 3
5 2
8 1
- -
a b
b에다가 a의 탑을 푸쉬한다.
-------------------------------------------------
Exec ra rb (equiv. to rr):
5 2
8 1
6 3
- -
a b
첫번쨰 엘리먼트가 마지막으로 간다 == 탑이 바텀으로 간다. 그리고 나머지는 위로간다.
즉 연결 리스트로 구현된 스택이라면, 탑을 프리브로 뺴고 바텀을 탑으로 바꾼다.
1. top과 bottom은 이어져있다.(가정)
2. top = bottom
3. bottom = top.next로 하면 될듯?
-------------------------------------------------
Exec rra rrb (equiv . to rrr):
6 3
5 2
8 1
- -
a b
마지막 엘리먼트가 처음으로 간다. == 바텀이 탑으로 간다. 그리고 나머지는 밑으로 간다.
연결리스트 이기 떄문에 나머지에 대한 구현은 필요하지 않다. 모든 것이 circular하다고 구현할 것이기 때문이다.
1. top과 bottom은 이어져있다.
2. bottom = bottom.next로 돌린다.
3. top = top.next로 돌린다.
-------------------------------------------------
Exec sa:
5 3
6 2
8 1
- -
a b
1. 2번쨰 요소 저장 이하 Ptop
2. top.prev.next = bottom으로 지정(Ptop.next란 의미)
3. top.prev.prev = top으로 지정(Ptop.prev란 의미)
4. bottom.prev = top이 될자의 next;
5. top.next = Ptop;
6. top = Ptop넣음 될듯?
-------------------------------------------------
Exec pa pa pa :
1
2
3
5
6
8
- -
a b
-------------------------------------------------
```
위의 예시는 12번의 명령어를 실행한다.

## 푸스스왑 프로그램

- 너는 푸시 스왑을 어규먼트를 통해서 받을 것이다. 첫번쨰 어규먼트는 반드시 스택의 탑에 간다.(순서 조심하자.)
  즉, 마지막 어규먼트부터 푸쉬해주면 된다.
- 프로그램은 반드시 최소한의 명령어를 보여줘야한다. 가장 작은 숫자가 탑에 들어간다.
- 목표는 최소한의 명령어로 스택을 쌓는 것이다.
  디펜스 동안에서 최대의 숫자를 기준으로 하면 좋을 것이다.
  만약 프로그램이 너무 크거나 소팅안되면 나가리다.
- 에러가 나오면 **Error\n**을 출력하면 된다.(당연히 standard error로). 에러는 인티저가 아니거나, 몇몇이 인티저보다 크거나 중복된 것이다.
- 만약 체커가 KO를 보여주면, 그것은 리스트가 소팅이 안되었다는 것이다. 체커는 인트라넷에 올라와있다.

## 보너스파트
